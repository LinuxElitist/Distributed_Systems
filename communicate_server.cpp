/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "communicate.h"
#include "article.h"
#include "communication.h"
#include <iostream>
#include <stdlib.h>
#include <unistd.h>
#include <string>
#include <string.h>

/*ERROR CODES:
0 - 7 : { "Success", "Client should first be joined", "Client should first be subscribed", "Wrong Format of article for operation",
          "Wrong Type of article", "UDP communication from server failed", "Operation Failed" }
*/

std::set<std::string> legal_types({"Sports", "Lifestyle", "Entertainment", "Business", "Technology", "Science", "Politics", "Health", ""});
std::set<Subscriber> subs_list;

int *
join_1_svc(char *ip, int port, struct svc_req *rqstp) {
    static int err_code = 6;

    Subscriber sub(ip, port);
    subs_list.insert(sub);
    std::cout << ip << " Joined at " << port << "\n";
    err_code = 0;

    return &err_code;
}

int *
leave_1_svc(char *ip, int port, struct svc_req *rqstp) {
    static int err_code = 6;

    Subscriber leaving_sub(ip, port);
    auto client = subs_list.find(leaving_sub);
    if (client != subs_list.end()) {
        subs_list.erase(client);
        std::cout << ip << " Left " << port << "\n";
        err_code = 0;
    } else {
        std::cout << ip << " should be joined for it to leave\n";
        err_code = 1;
    }

    return &err_code;
}

int *
subscribe_1_svc(char *ip, int port, char *article, struct svc_req *rqstp) {
    static int err_code = 6;
    Subscriber sub(ip, port);
    Article art(article);
    if (((art.type == "") && (art.orig == "") && (art.org == "")) or (art.content != "")) {
        std::cout << ip << " failed to subscribe for \"" << article
                  << "\" : Wrong Format for Subscription (Atleast one of type, originator or org should be presents and content should be empty)\n";
        err_code = 3;
    } else if (legal_types.find(art.type) != legal_types.end()) {
        auto sub_it = subs_list.find(sub);
        if (sub_it != subs_list.end()) {
            (*sub_it).articles.insert(art);
            std::cout << (*sub_it).ip << " subscribed for \"" << art.type << ";" << art.orig << ";" << art.org
                      << "\"\n";
            err_code = 0;
        } else {
            std::cout << (*sub_it).ip << " should be joined for it to be subscribed\n ";
            err_code = 1;
            //Need not be handled in unsubscribe or publish as first it shd be subscribed which is possible only when it has joined
        }
    } else {
        std::cout << "Type in article should be one of these: <Sports, Lifestyle, Entertainment, Business, Technology, Science, Politics, Health>\n ";
        err_code = 4;
    }
    return &err_code;
}

int *
unsubscribe_1_svc(char *ip, int port, char *article, struct svc_req *rqstp) {
    static int err_code = 6;
    Subscriber sub(ip, port);
    Article art(article);

    if ((art.type == "") && (art.orig == "") && (art.org == "")) {
        std::cout << ip << " failed to unsubscribe for \"" << article
                  << "\" : Wrong Format for Unsubscription (Atleast one of type, originator or org should be present and content should be empty)\n";
        err_code = 3;
    } else if (legal_types.find(art.type) != legal_types.end()) {
        auto sub_it = subs_list.find(sub);
        if (sub_it != subs_list.end()) {
            if ((*sub_it).subscribed(art)) {
                (*sub_it).unsubscribed(art);
                std::cout << (*sub_it).ip << " unsubscribed from \"" << art.type << ";" << art.orig << ";" << art.org
                          << "\"\n";
                err_code = 0;
            } else {
                std::cout << (*sub_it).ip << " should be subscribed to \"" << article << "\" for unsubscription \n";
                err_code = 2;
            }
        } else {
            std::cout << (*sub_it).ip << " should be joined for it to unsubscribe\n";
            err_code = 1;
        }
    } else {
        std::cout << "Type in article should be one of these: <Sports, Lifestyle, Entertainment, Business, Technology, Science, Politics, Health>\n ";
        err_code = 4;
    }
    return &err_code;
}

int *
publish_1_svc(char *article, char *ip, int port, struct svc_req *rqstp) {
    static int err_code = 6;
    Subscriber sub(ip, port);
    Article art(article);
    if (((art.type == "") && (art.orig == "") && (art.org == "")) or (art.content == "")) {
        std::cout << ip << " failed to publish \"" << article
                  << "\" : Wrong Format for Publish (Atleast one of type, originator ot organization should be presents and contents MUST be present)\n";
        err_code = 3;
    } else if (legal_types.find(art.type) != legal_types.end()) {
        for (auto sub_it = subs_list.begin(); sub_it != subs_list.end(); ++sub_it) {
            if ((*sub_it).subscribed(art)) {
                err_code = send_client((*sub_it), article);            ///////TODO handling send_client just content or article
                std::cout << "\"" << art.content << " for \"" << art.type << ";" << art.orig << ";" << art.org << "\" was published; article sent to " << (*sub_it).ip << "\n";
            } else {
                err_code = 0;
            }
        }
    } else {
        std::cout << "Type in article should be one of these: <Sports, Lifestyle, Entertainment, Business, Technology, Science, Politics, Health>\n ";
        err_code = 4;
    }

    return &err_code;
}

int *
ping_1_svc(struct svc_req *rqstp) {
    static int err_code = 6;

    //std::cout << "ping received\n";
    err_code = 0;

    return &err_code;
}
